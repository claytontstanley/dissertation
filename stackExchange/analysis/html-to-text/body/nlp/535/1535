i
've
never
been
completely
happy
with
the
way
exception
handling
work
,
there
's
a
lot
exception
and
try/catch
brings
to
the
table
(
stack
unwinding
,
etc.
)
,
but
it
seems
to
break
a
lot
of
the
oo
model
in
the
process.
anyway
,
here
's
the
problem
:
let
's
say
you
have
some
class
which
wrap
or
includes
networked
file
io
operation
(
e.g.
reading
and
writing
to
some
file
at
some
particular
unc
path
somewhere
)
.
for
various
reason
you
do
n't
want
those
io
operation
to
fail
,
so
if
you
detect
that
they
fail
you
retry
them
and
you
keep
retrying
them
until
they
succeed
or
you
reach
a
timeout.
i
already
have
a
convenient
retrytimer
class
which
i
can
instantiate
and
use
to
sleep
the
current
thread
between
retries
and
determine
when
the
timeout
period
ha
elapsed
,
etc.
the
problem
is
that
you
have
a
bunch
of
io
operation
in
several
method
of
this
class
,
and
you
need
to
wrap
each
of
them
in
try-catch
/
retry
logic.
here
's
an
example
code
snippet
:
retrytimer
fileioretrytimer
=
new
retrytimer
(
timespan.fromhours
(
10
)
)
;
bool
success
=
false
;
while
(
!
success
)
{
try
{
//
do
some
file
io
which
may
succeed
or
fail
success
=
true
;
}
catch
(
ioexception
e
)
{
if
(
fileioretrytimer.hasexceededretrytimeout
)
{
throw
e
;
}
fileioretrytimer.sleepuntilnextretry
(
)
;
}
}
so
,
how
do
you
avoid
duplicating
most
of
this
code
for
every
file
io
operation
throughout
the
class
?
my
solution
wa
to
use
anonymous
delegate
block
and
a
single
method
in
the
class
which
executed
the
delegate
block
passed
to
it.
this
allowed
me
to
do
thing
like
this
in
other
method
:
this.retryfileio
(
delegate
(
)
{
//
some
code
block
}
)
;
i
like
this
somewhat
,
but
it
leaf
a
lot
to
be
desired.
i
'd
like
to
hear
how
other
people
would
solve
this
sort
of
problem
.