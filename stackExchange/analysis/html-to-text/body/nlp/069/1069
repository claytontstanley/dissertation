i
'm
working
on
a
multithreaded
c++
application
that
is
corrupting
the
heap.
the
usual
tool
to
locate
this
corruption
seem
to
be
inapplicable.
old
build
(
18
month
old
)
of
the
source
code
exhibit
the
same
behaviour
a
the
most
recent
release
,
so
this
ha
been
around
for
a
long
time
and
just
wa
n't
noticed
;
on
the
downside
,
source
delta
ca
n't
be
used
to
identify
when
the
bug
wa
introduced
-
there
are
a
lot
of
code
change
in
the
repository.
the
prompt
for
crashing
behaviuor
is
to
generate
throughput
in
this
system
-
socket
transfer
of
data
which
is
munged
into
an
internal
representation.
i
have
a
set
of
test
data
that
will
periodically
cause
the
app
to
exception
(
various
place
,
various
cause
-
including
heap
alloc
failing
,
thus
:
heap
corruption
)
.
the
behaviour
seems
related
to
cpu
power
or
memory
bandwidth
;
the
more
of
each
the
machine
ha
,
the
easier
it
is
to
crash.
disabling
a
hyper-threading
core
or
a
dual-core
core
reduces
the
rate
of
(
but
doe
not
eliminate
)
corruption.
this
suggests
a
timing
related
issue.
now
here
's
the
rub
:
when
it
's
run
under
a
lightweight
debug
environment
(
say
visual
studio
98
/
aka
msvc6
)
the
heap
corruption
is
reasonably
easy
to
reproduce
-
ten
or
fifteen
minute
pas
before
something
fails
horrendously
and
exception
,
like
an
alloc
;
when
running
under
a
sophisticated
debug
environment
(
rational
purify
,
vs2008/msvc9
or
even
microsoft
application
verifier
)
the
system
becomes
memory-speed
bound
and
doe
n't
crash
(
memory-bound
:
cpu
is
not
getting
above
50
%
,
disk
light
is
not
on
,
the
program
's
going
a
fast
it
can
,
box
consuming
1.3g
of
2g
of
ram
)
.
so
,
i
've
got
a
choice
between
being
able
to
reproduce
the
problem
(
but
not
identify
the
cause
)
or
being
able
to
idenify
the
cause
or
a
problem
i
ca
n't
reproduce.
my
current
best
guess
a
to
where
to
next
is
:
get
an
insanely
grunty
box
(
to
replace
the
current
dev
box
:
2gb
ram
in
an
e6550
core2
duo
)
;
this
will
make
it
possible
to
repro
the
crash
causing
mis-behaviour
when
running
under
a
powerful
debug
environment
;
or
rewrite
operator
new
and
delete
to
use
virtualalloc
and
virtualprotect
to
mark
memory
a
read-only
a
soon
a
it
's
done
with.
run
under
msvc6
and
have
the
os
catch
the
bad-guy
who
's
writing
to
freed
memory.
yes
,
this
is
a
sign
of
desperation
:
who
the
hell
rewrite
new
and
delete
?
!
i
wonder
if
this
is
going
to
make
it
a
slow
a
under
purify
et
al.
and
,
no
:
shipping
with
purify
instrumentation
built
in
is
not
an
option.
a
collegue
just
walked
past
and
asked
``
stack
overflow
?
are
we
getting
stack
overflow
now
?
!
?
''
and
now
,
the
question
:
how
do
i
locate
the
heap
corruptor
?
update
:
balancing
new
[
]
and
delete
[
]
seems
to
have
gotten
a
long
way
towards
solving
the
problem.
instead
of
15mins
,
the
app
now
go
about
two
hour
before
crashing.
not
there
yet.
any
further
suggestion
?
the
heap
corruption
persists.
update
:
a
release
build
under
visual
studio
2008
seems
dramatically
better
;
current
suspicion
rest
on
the
stl
implementation
that
ship
with
vs98
.