is
there
a
way
to
implement
a
singleton
object
in
c++
that
is
:
lazily
constructed
in
a
thread
safe
manner
(
two
thread
might
simultaneously
be
the
first
user
of
the
singleton
-
it
should
still
only
be
constructed
once
)
.
does
n't
rely
on
static
variable
being
constructed
beforehand
(
so
the
singleton
object
is
itself
safe
to
use
during
the
construction
of
static
variable
)
.
(
i
do
n't
know
my
c++
well
enough
,
but
is
it
the
case
that
integral
and
constant
static
variable
are
initialized
before
any
code
is
executed
(
ie
,
even
before
static
constructor
are
executed
-
their
value
may
already
be
``
initialized
''
in
the
program
image
)
?
if
so
-
perhaps
this
can
be
exploited
to
implement
a
singleton
mutex
-
which
can
in
turn
be
used
to
guard
the
creation
of
the
real
singleton..
)
excellent
,
it
seems
that
i
have
a
couple
of
good
answer
now
(
shame
i
ca
n't
mark
2
or
3
a
being
the
answer
)
.
there
appears
to
be
two
broad
solution
:
use
static
initialisation
(
a
opposed
to
dynamic
initialisation
)
of
a
pod
static
variable
,
and
implementing
my
own
mutex
with
that
using
the
builtin
atomic
instructions.
this
wa
the
type
of
solution
i
wa
hinting
at
in
my
question
,
and
i
believe
i
knew
already.
use
some
other
library
function
like
pthread_once
or
boost
:
:call_once
.
these
i
certainly
did
n't
know
about
-
and
am
very
grateful
for
the
answer
posted
.