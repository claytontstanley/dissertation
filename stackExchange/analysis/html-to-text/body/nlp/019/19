solutions
welcome
in
any
language.
:
-
)
i
'm
looking
for
the
fastest
way
to
obtain
the
value
of
pi
,
a
a
personal
challenge.
more
specifically
i
'm
using
way
that
do
n't
involve
using
#
defined
constant
like
m_pi
,
or
hard-coding
the
number
in.
the
program
below
test
the
various
way
i
know
of.
the
inline
assembly
version
is
,
in
theory
,
the
fastest
option
,
though
clearly
not
portable
;
i
've
included
it
a
a
baseline
to
compare
the
other
version
against.
in
my
test
,
with
built-ins
,
the
4
*
atan
(
1
)
version
is
fastest
on
gcc
4.2
,
because
it
auto-folds
the
atan
(
1
)
into
a
constant.
with
-fno-builtin
specified
,
the
atan2
(
0
,
-1
)
version
is
fastest.
here
's
the
main
testing
program
(
pitimes.c
)
:
#
include
<
math.h
>
#
include
<
stdio.h
>
#
include
<
time.h
>
#
define
iters
10000000
#
define
testwith
(
x
)
{
\
diff
=
0.0
;
\
time1
=
clock
(
)
;
\
for
(
i
=
0
;
i
<
iters
;
++i
)
\
diff
+=
(
x
)
-
m_pi
;
\
time2
=
clock
(
)
;
\
printf
(
``
%
s\t=
>
%
e
,
time
=
>
%
f\n
''
,
#
x
,
diff
,
diffclock
(
time2
,
time1
)
)
;
\
}
static
inline
double
diffclock
(
clock_t
time1
,
clock_t
time0
)
{
return
(
double
)
(
time1
-
time0
)
/
clocks_per_sec
;
}
int
main
(
)
{
int
i
;
clock_t
time1
,
time2
;
double
diff
;
/*
warmup.
the
atan2
case
catch
gcc
's
atan
folding
(
which
would
*
optimise
the
``
4
*
atan
(
1
)
-
m_pi
''
to
a
no-op
)
,
if
-fno-builtin
*
is
not
used.
*/
testwith
(
4
*
atan
(
1
)
)
testwith
(
4
*
atan2
(
1
,
1
)
)
#
if
defined
(
__gnuc__
)
&
&
(
defined
(
__i386__
)
||
defined
(
__amd64__
)
)
extern
double
fldpi
(
)
;
testwith
(
fldpi
(
)
)
#
endif
/*
actual
test
start
here.
*/
testwith
(
atan2
(
0
,
-1
)
)
testwith
(
acos
(
-1
)
)
testwith
(
2
*
asin
(
1
)
)
testwith
(
4
*
atan2
(
1
,
1
)
)
testwith
(
4
*
atan
(
1
)
)
return
0
;
}
and
the
inline
assembly
stuff
(
fldpi.c
)
,
noting
that
it
will
only
work
for
x86
and
x64
system
:
double
fldpi
(
)
{
double
pi
;
asm
(
``
fldpi
''
:
``
=t
''
(
pi
)
)
;
return
pi
;
}
and
a
build
script
that
build
all
the
configuration
i
'm
testing
(
build.sh
)
:
#
!
/bin/sh
gcc
-o3
-wall
-c
-m32
-o
fldpi-32.o
fldpi.c
gcc
-o3
-wall
-c
-m64
-o
fldpi-64.o
fldpi.c
gcc
-o3
-wall
-ffast-math
-m32
-o
pitimes1-32
pitimes.c
fldpi-32.o
gcc
-o3
-wall
-m32
-o
pitimes2-32
pitimes.c
fldpi-32.o
-lm
gcc
-o3
-wall
-fno-builtin
-m32
-o
pitimes3-32
pitimes.c
fldpi-32.o
-lm
gcc
-o3
-wall
-ffast-math
-m64
-o
pitimes1-64
pitimes.c
fldpi-64.o
-lm
gcc
-o3
-wall
-m64
-o
pitimes2-64
pitimes.c
fldpi-64.o
-lm
gcc
-o3
-wall
-fno-builtin
-m64
-o
pitimes3-64
pitimes.c
fldpi-64.o
-lm
apart
from
testing
between
various
compiler
flag
(
i
've
compared
32-bit
against
64-bit
too
,
because
the
optimisation
are
different
)
,
i
've
also
tried
switching
the
order
of
the
test
around.
the
atan2
(
0
,
-1
)
version
still
come
out
top
every
time
,
though.
i
'm
keen
to
hear
what
result
you
have
,
a
well
a
improvement
to
the
testing
process.
:
-
)