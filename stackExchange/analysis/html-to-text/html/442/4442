<p>I just keep stumbling through mocking...</p>

<p>The latest disaster was not grokking that I need to actually push results inside a mock object of IEnumerable...</p>

<p>Here's a sample (demonstration only of IEnumerable, not actually good Interaction-based testing!):</p>

<pre><code>using System;
using System.Collections.Generic;
using Rhino.Mocks;
using MbUnit.Framework;

[TestFixture]
public class ZooTest{

    [Test]
    public void ZooCagesAnimals()
    {
        MockRepository mockery = new MockRepository();

        IZoo zoo = new Zoo();

        //this is the part that feels wrong to create
        IList&lt;IAnimal&gt; mockResults = mockery.DynamicMock&lt;IList&lt;IAnimal&gt;&gt;();
        IAnimal mockLion = mockery.DynamicMock&lt;IAnimal&gt;();
        IAnimal mockRhino = mockery.DynamicMock&lt;IAnimal&gt;();

        using (mockery.Record())
        {
            Expect.Call(zoo.Animals)
                .Return(mockResults)
                .Repeat.Once();
        }

        using (mockery.Playback())
        {
            zoo.CageThe(mockLion);
            zoo.CageThe(mockRhino);

            Assert.AreEqual(mockResults, new List&lt;IAnimal&gt;(zoo.Animals));
        }


    }
}


public class Zoo : IZoo
{
    private IList&lt;IAnimal&gt; animals = new List&lt;IAnimal&gt;();

    public void CageThe(IAnimal animal)
    {
        animals.Add(animal);
    }

    public IEnumerable&lt;IAnimal&gt; Animals
    {
        get
        {
            foreach(IAnimal animal in animals)
            {
                yield return animal;
            }
        }
    }
}

public interface IAnimal
{
}

public interface IZoo
{
    IEnumerable&lt;IAnimal&gt; Animals { get;}
    void CageThe(IAnimal animal);
}
</code></pre>

<p>I don't like how I got it to work for the following reasons:</p>

<ul>
<li>Had to consume the IEnumerable results into IList, I understand this puts the results for checking onto the heap</li>
<li>Had to setup the contents of the results ... <strong>I understand this as well, but my main point is to test that Zoo.Animals is returning IEnumerable, and even better, that we're using "yield return" inside</strong></li>
</ul>

<p>Any suggestions on doing this better, or simpler?</p>

<p><strong>Edit:</strong> I'm trying to determine the optimal way to test the interaction between IEnumerable and whatever I'm using.  I'm not trying to test that Zoo can hold animals, rather that Zoo exposese as IEnumerable, and that <code>yield return</code> is getting used as well.</p>