<p>Does anyone have, or know of, a binary patch generation algorithm implementation in C#?</p>

<p>Basically, compare two files (designated <em>old</em> and <em>new</em>), and produce a patch file that can be used to upgrade the <em>old</em> file to have the same contents as the <em>new</em> file.</p>

<p>The implementation would have to be relatively fast, and work with huge files. It should exhibit O(n) or O(logn) runtimes.</p>

<p>My own algorithms tend to either be lousy (fast but produce huge patches) or slow (produce small patches but have O(n^2) runtime).</p>

<p>Any advice, or pointers for implementation would be nice.</p>

<p>Specifically, the implementation will be used to keep servers in sync for various large datafiles that we have one master server for. When the master server datafiles change, we need to update several off-site servers as well.</p>

<p>The most naive algorithm I have made, which only works for files that can be kept in memory, is as follows:</p>

<ol>
<li>Grab the first four bytes from the <em>old</em> file, call this the <em>key</em></li>
<li>Add those bytes to a dictionary, where <em>key -> position</em>, where <em>position</em> is the position where I grabbed those 4 bytes, 0 to begin with</li>
<li>Skip the first of these four bytes, grab another 4 (3 overlap, 1 one), and add to the dictionary the same way</li>
<li>Repeat steps 1-3 for all 4-byte blocks in the <em>old</em> file</li>
<li>From the start of the <em>new</em> file, grab 4 bytes, and attempt to look it up in the dictionary</li>
<li>If found, find the longest match if there are several, by comparing bytes from the two files</li>
<li>Encode a reference to that location in the <em>old</em> file, and skip the matched block in the <em>new</em> file</li>
<li>If not found, encode 1 byte from the <em>new</em> file, and skip it</li>
<li>Repeat steps 5-8 for the rest of the <em>new</em> file</li>
</ol>

<p>This is somewhat like compression, without windowing, so it will use a lot of memory. It is, however, fairly fast, and produces quite small patches, as long as I try to make the codes output minimal.</p>

<p>A more memory-efficient algorithm uses windowing, but produces much bigger patch files.</p>

<p>There are more nuances to the above algorithm that I skipped in this post, but I can post more details if necessary. I do, however, feel that I need a different algorithm altogether, so improving on the above algorithm is probably not going to get me far enough.</p>

<p><hr /></p>

<p><strong>Edit #1</strong>: Here is a more detailed description of the above algorithm.</p>

<p>First, combine the two files, so that you have one big file. Remember the cut-point between the two files.</p>

<p>Secondly, do that <em>grab 4 bytes and add their position to the dictionary</em> step for everything in the whole file.</p>

<p>Thirdly, from where the <em>new</em> file starts, do the loop with attempting to locate an existing combination of 4 bytes, and find the longest match. Make sure we only consider positions from the old file, or from <em>earlier in the new file than we're currently at</em>. This ensures that we can reuse material in both the old and the new file during patch application.</p>

<p><hr /></p>

<p><strong>Edit #2</strong>: <a href="http://code.google.com/p/lvknet/source/browse/trunk/LVK/IO/Patching/Binary/BinaryPatch.cs" rel="nofollow">Source code to the above algorithm</a></p>

<p>You might get a warning about the certificate having some problems. I don't know how to resolve that so for the time being just accept the certificate.</p>

<p>The source uses lots of other types from the rest of my library so that file isn't all it takes, but that's the algorithm implementation.</p>
